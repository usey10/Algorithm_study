# 자료구조

## 선형 자료구조
### 0. 기본

#### 배열
- 많은 수의 데이터를 다룰 때 사용하는 자료구조
- 각 데이터를 인덱스와 1:1 대응하도록 구성
- 데이터가 메모리 상에 연속적으로 저장됨.

- 특징
    - 크기(element) 의 개수가 정해져 있음.
    - 자료구조에 기능(메소드)이 포함되어있지 않음.
    - 자료가 메모리상에 빈틈 없이 연속적으로 위치해 있음.
    - 인덱스를 활용하여 자료에 빠르게 접근할 수 있음.
- 단점
    - 배열의 길이는 생성 시 정해져, 변경할 수 없음.
    - element 를 제거 시, 배열에 빈틈이 생김(빈틈 유지, 즉 실제 element 의 삭제 불가)

#### 리스트
- 순서가 있는 자료를 다루는 추상 자료형
- 추상 자료형이기 떄문에, 구현 방법이 명시되어 있지 않음.
- 대표적인 리스트를 구현한 자료 구조 - 배열 리스트, 연결 리스트
- 리스트 연산자
    - 비어있는 리스트 생성 연산자 : __init__()
    - 비어있는지 확인 : is_empty()
    - 앞에 개체 삽입 : pretend()
    - 뒤에 개체 삽입 : append()
    - 첫 머리를(head) 를 결정하는 연산자: set_head() (python slice)
    - 주어진 인덱스의 접근 : access(), get()
    - 주어진 인덱스에 삽입 : insert()
    - 주어진 인덱스 요소 제거 : remove()

---

### 1. 배열 리스트
- 내부적으로 배열을 이용하여 구현하는 리스트
- 리스트 추상자료형에서 요구하는 연산자를 배열을 활용하여 구현
- 배열의 장점인 임의접근이 핵심

### 2. 연결 리스트
- 리스트를 구현한 자료구조, 자료를 연결하여 관리하는 자료구조
- 자료의 순서는  정해져 있으나 메모리에서의 연속성은 보장하지 않음.
- 장점
    - 차지할 메모리를 미리 할당할 필요가 없음.
    -  자료의 추가/제거가 용이함.
- 단점
    - 자료간의 연결을 위한 추가 메모리가 필요함
    - 원하는 인덱스의 자료를 찾는 접근 속도가 느림, 임의 접근 불가
    - 배열 리스트에 비해 구현이 상대적으로 복잡함.
- 구조
    - 단반향 연결 리스트 : 자료의 값과 연결 정보를 가진 노드(node)로 구성
    - 양방향 연결 리스트 : 양방향으로 노드를 연결하는 이중 연결 구조
- 연결 리스트 연산자
    - 비어있는 리스트 생성 연산자 : __init__()
    - 비어있는지 확인 : is_empty()
    - 앞에 개체 삽입 : pretend()
    - 뒤에 개체 삽입 : append()
    - 첫 머리를(head) 를 결정하는 연산자: set_head() (python slice)
    - 주어진 인덱스의 접근 : access(), get()
    - 주어진 인덱스에 삽입 : insert()
    - 주어진 인덱스 요소 제거 : remove()

### 3. 스택
- 리스트와 달리 기능을 제한하는 추상자료형(ADT)
- 후입 선출의 특성
- 자료가 입력된 역순으로 처리되어야 할 떄 사용
- 스택의 연산자
    - push() : 자료를 top 위에 삽입하는 연산자
    - pop() : 자료를 top 에서 꺼내는 연산자
    - peek() : top에 있는 자료를 반환하지만, 삭제하지는 않는 연산자
    - is_empty() : 스택이 비어있는지 확인하는 연산자
- 스택의 구현
    - 배열을 사용하므로, 크기가 정해져 있음.
    - 메모리상 자료가 연속적이기 때문에 동작 속도가 빠름.
- 오버플로우와 언더플로우
    - 스택은 고속 동작을 위해 보통 배열로 구현
    - 오버플로우 : 스택이 가득 차있을때 push 시(메모리 공간 부족)
    - 언더플로우 : 스택이 비어있을 때 pop 시 (프로그램 버그)

### 4. 큐(Queue)
- 스택과 유사하게 기능을 제한하는 추상자료형(ADT)
- 선입선출의 특성
- 자료가 입력된 순서대로 처리되어야 할 떄 사용.
- 큐의 연산자
    - 큐는 자료를 넣는 곳, 빼는 곳이 따로 정해져 있음.(앞 : rear / 뒤 : front)
    - put(), enqueue() : 자료를 rear 로 삽입하는 연산자
    - get(), dequeue() : 자료를 front 에서 꺼내는 연산자
    - peek() : front 에 있는 자료를 반환하지만, 삭제하지는 않는 연산자
- 큐의 구현
    - 선형 큐
        - 배열을 이용하여 구현하는 가장 기본적인 큐
        - 문제점 : 한번 사용한 메모리 공간이 버려짐 + 반드시 오버플로우가 발생하는 구조적 문제
    - 환형 큐
        - 선형 큐의 시작과 끝을 연결해서 메모리를 재활용함.
        - 배열을 가득 채우기 전까지 오버플로우가 발생하지 않음.
        - 자료를 빼는 속도보다 넣는 속도가 빠른 경우는 오버플로우가 발생됨.
    - 연결 리스트 큐(실제 사용하는 큐의 형태)
        - 연결 리스트를 이용해 큐 구현
        - 구조적으로 메모리의 제약이 없음.

### 5. 해싱(Hashing)
- 해싱
    - 넓은 범위의 값을 더 좁은 범위의 값으로 변환하는 기법
    - 동일한 입력에 대해서 항상 동일한 출력을 보장
- 해시 함수(Hash function)
    - 해싱에 사용되는 함수로, 자주 사용되므로 빠른 동작이 요구됨.
    - 해시 충돌(Hash collision) : 다른 입력이 동일한 출력을 가질 수 있음.
    - python 에서 hash() 라는 내장 함수가 있음.

- 해시 셋(Hash set)
    - 해싱 기법을 이용하는 대표적인 자료구조
    - 한정된 크기를 가지는 버킷(bucket -> 배열) 을 이용해 자료를 저장
    - 자료를 저장하는 인덱스는 해시값(해시 함수의 출력)을 버킷의 크기로 나눈 나머지로 한다 (index = hash_value % bucket_size)
    - 특징
        - 파이썬에는 set 자료형으로 해시 셋 구성
        - 자료의 중복 허용하지 않음. + 자료를 빠르게 탐색 가능
        - 버킷이 가득 차면 버킷의 크기를 증가 + 재배치

- 해시 테이블(Hash table)
    - 해시 셋과 유사하나, 해시를 계산하는 key와 짝을 이루는 valu를 함께 버킷에 저장하는 자료 구조
    - 파이썬에서는 dict 의 형식으로 구현
    - key는 중복이 허용되지 않고, value는 중복이 허용됨.
    - 공간 복잡도를 희생하여 시간 복잡도를 낮추는 대표적인 자료구조(메모리를 많이 써서 빠른 가져오기가 가능)

- 해시 충돌(Hash collision)
    - 해시 함수가 서로 다른 입력에 대해 동일한 출력을 내는 경우
    - 해시 충돌이 100% 발생할 경우, 탐색 성능은 O(1) 에서 O(N)으로 감소
    - 해결 방법
        - 개방 주소법(Open addressing, closed hashing)
            - 버킷의 다른 index를 선택하여 자료를 저장하는 기법
            - 더 이상 해시 충돌이 발생하지 않을 때까지 반복
            - 종류
                - 선형 탐사(Linear probing) : index 를 1씩 이동
                - 이차 탐사(Quadratic probing) : index 를 1², 2² ~ 씩 이동
                - 이중 해싱(Double hashing) : 별도의 해시 함수로 이동 간격을 계산(가장 성능이 좋음)
        - 체이닝(Chaining)
            - 해시 충돌이 발생할 경우 버킷에 자료를 연결 리스트로 추가해 나가는 기법

## 비선형 자료구조
### 1. 트리 이론
- 트리
    - 부모와 자식 관계로 이어진 노드의 집합으로 이루어진 구조
    - 계층적 구조를 나타낼 때 주로 사용
    - 구조
        - 노드(node) : 트리 구조의 자료값을 담고 있는 단위
        - 에지(edge) : 노드 간의 연결선(=link, branch)
        - 루트 노드(Root) : 부모가 없는 노드, 가장 위의 노드
        - 잎새 노드(Leaf) : 자식이 없는 노드(=단말)
        - 내부 노드(Internal) : 잎새 노드를 제외한 모든 노드
        - 부모(Parent) : 연결된 두 노드 중 상위 노드
        - 자식(Child) : 연결된 두 노드 중 하위 노드
        - 형제(Sibling) : 같은 부모를 가지는 노드
        - 깊이(Depth) : 루트에서 어떤 노드까지의 간선의 수
        - 레벨(Level) : 트리의 특정 깊이를 가지는 노드 집합
        - 높이(Height) : 트리에서 가장 큰 레벨 값
        - 크기(Size) : 자신을 포함한 자식 노드의 개수
        - 차수(Degree) : 각 노드가 지닌 가지의 수
        - 트리의 차수 : 트리의 최대 차수
    - 특징
        - 하나의 노드에서 다른 노드로 이동하는 경로는 유일
        - 노드가 N 개인 트리의 간선의 수는 N-1
        - Acyclic(서클이 존재하지 않음.)
        - 모든 노드는 서로 연결되어 있음.
        - 하나의 간선을 끊으면 2개의 부분트리(sub-tree) 로 분리됨.
- 이진 트리
    - 각 노드는 최대 2개의 자식을 가질 수 있음.
    - 자식 노드는 좌우를 구분함(왼쪽 자식/오른쪽 자식, 두개 위치 바뀌면 다른 트리임.)
    - 종류
        - 포화 이진 트리(Perfect binary tree) : 모든 레벨에서 노드들이 꽉 채워져 있는 트리
        - 완전 이진 트리(Complete binary tree) : 마지막 레벨을 제외하고 노드들이 모두 채워져 있는 트리
        - 정 이진 트리(Full binary tree) : 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리
        - 편향 트리(Skewed binary tree) : 한쪽으로 기울어진 트리(연결리스트와 동일)
        - 균형 이진 트리(Balanced binary tree) : 모든 노드의 좌우 서브 트리 높이가 1 이상 차이 나지 않는 트리
    - 특징
        - 포화 이진 트리 높이가 h 일때, 노드의 수는 2ʰ⁺¹ -1개
        - 포화(or 완전) 이진 트리의 노드가 N개 일때 높이는 𝒍𝒐𝒈₂N
        - 이진 트리의 노드가 N개일 때, 최대 가능 높이는 N
    - 순회(Traversal)
        - 모든 노드를 빠뜨리거나 중복하지 않고 방문하는 연산
        - 비선형 자료구조이기 때문에 다양한 순회 방법이 있다.
        - 전위 순회, 대칭 순회, 후위 순회 - 재귀적 순회 방법
        - 레벨 순회 - 레벨 별 순회 방법
        - 전위 순회(Preorder traversal)
            - 깊이 우선 순회(Depth first traversal)
            - 방문 순서 : 현재 노드 - 왼쪽 노드 - 오른쪽 노드
        - 대칭 순회
            - 방문 순서 : 왼쪽 노드 - 현재 노드 - 오른쪽 노드
        - 후위 순회(Postorder traversal)
            - 방문 순서 : 왼쪽 노드 - 오른쪽 노드 - 현재 노드
        - 레벨 순회(Level order traversal)
            - 너비 우선 순회(Breadth first traversal)
            - 방문 순서 : 위쪽 레벨부터 왼쪽 노드 -> 오른쪽 노드
    - 완전 이진 트리의 구현
        - 배열에 레벨 순회 순서대로 배열로 구현
    - 일반적인 이진 트리의 구현
        - Node 클래스를 이용하여 구현
        - value, left, right 멤버 변수를 가지는 클래스
        - Root node 를 멤버 변수로 가지는 클래스 Tree 로 구현

### 2. 힙 이론
- 완전 이진 트리의 일종, 우선순위 큐(Priority queue)
- 최소값 또는 최대값을 빠르게 찾아내는데 유용한 자료구조
- 최소 힙(Min heap)
    - 부모 노드의 value ≤ 자식 노드의 value 상태로 항상 정렬되어있는 자료 구조
    - 동일한 자료에 대해서 여러 가지 최소 힙이 성립
    - 직계 부모와의 관계에서만 성립, 레벨이 높을수록 값이 높음
- 최대 힙(Max heap)
    - 부모 노드의 value ≥ 자식 노드의 value 상태로 항상 정렬되어있는 자료 구조
    - 동일한 자료에 대해서 여러가지 최대 힙이 성립
- 최소 힙 - 삽입 프로세스
    - 트리의 가장 끝 위치에 데이터 삽입
    - 부모 노드와 비교한 후 작을 경우 부모 자리와 교체(반복)
    - 높이 : log₂𝑵
- 최소 힙 - 삭제 프로세스
    - 최상위 노드 반환 및 삭제
    - 가장 마지막 위치의 노드를 최상위 노드로 위치
    - 자식 노드 중 작은 값과 비교 후 부모 노드가 더 크면 자리 교체(반복)

- 장점
    - 일반 배열에서 최대/최소 값 탐색 : O(N)
    - 일반 배열에서 새로운 자료 추가 : O(1)

    - 정렬 배열에서 최대/최소 값 탐색 : O(1)
      (단, 정렬하는 연산 O(𝑵log𝑵)이 선행되어야 함.)
    - 정렬 배열에서 새로운 자료 추가 : O(𝑵)

    - 힙에서 최대/최고 값 탐색 : O(log𝑵)
    - 힙에서 새로운 자료 추가 : O(log𝑵)
    - 즉, 두 가지 연산에서 시간 복잡도가 낮음.

### 3. 그래프 이론

- 객체 간에 짝을 이루는 가장 유연한 자료 구조
- 정점(vertex, node, point, -> 객체) 과 이를 잇는 간선으로 구성
- 간선은 무향 또는 유향일 수 있다.(방향성이 있을 수도 없을 수도 있음.)
- 간선은 가중치가 있을 수 있고, 이는 연결의 강도 혹은 간선의 길이를 의미한다.
- 구조
    - 정점(Vertax) : 각 노드
    - 간선(Edge) : 노드와 노드를 연결하는 선
    - 인접 정점(Adjacent vertex) : 간선 하나를 두고 바로 연결된 정점
    - 정점의 차수(Degree) : 무방향 그래프에서 하나의 정점에 인접한 정점의 수 또는 무방향 그래프 모든 정점 차수의 합(그래프 간선의 수 2배)
    - 진입 차수(In-degree) : 방향 그래프에서 외부에서 오는 간선의 수
    - 진출 차수(Out-degree) : 방향 그래프에서 외부로 나가는 간선의 수
    - 경로 길이(Path length) : 경로를 구성하는데 사용된 간선의 수
    - 단순 경로(Simple path) : 경로 중에서 반복되는 정점이 없는 경우
    - 사이클(Cycle) : 단순 경로의 시작 정점과 끝 정점이 동일한 경우
- 구현
    - 인접 행렬(Adjacency matrix)
        - 2차원 배열 이용
        - 간선이 많을 때 사용
        - 장단점
            - 간선 정보의 확인과 업데이트가 빠름(O(1))
            - 인접 행렬을 위한 메모리 공간 차지(O(N²))
    - 인접 리스트(Adjacency list)
        - 연결 리스트 이용
        - 간선이 상대적으로 적을 때 사용
        - 장단점
            - 메모리를 상대적으로 적게 사용, 노드의 추가 및 삭제가 빠름
            - 간선 정보 확인이 상대적으로 오래 걸림.
- 종류
    - 무방향 그래프(Undirected graph)
        - 간선에 방향이 없는 그래프(양방향 이동 가능)
        - A - B 표현 : `(A,B) = (B,A)`
    - 방향 그래프(Directed graph)
        - 간선에 방향이 있느 그래프(해당 방향으로만 이동 가능)
        - A → B 표현 : `<A,B> ≠ <B,A>`
    - 가중치 그래프(Weighted graph)
        - 간선에 가중치가 있는 그래프(이동 비용 또는 연결 강도)
        - 가중치 + 방향 그래프 같이 나올 수 있음.
    - 완전 그래프(Complete graph)
        - 모든 정점이 서로 연결되어 있는 그래프
        - 정점이 N 개일 경우, 간선의 수는 ɴ𝐶₂(N(N-1)/2)
- 탐색
    - 깊이 우선 탐색(Depth first search; DFS)
        - 사이클이 있기 때문에 돌아올 수 있음.
        - visited 배열과 스택 또는 재귀적으로 구현(Preorder)
    - 너비 우선 탐색(Breath first search; BFS)
        - 큐로 구현
        - visited 배열과 큐를 이용하여 구현
        - 시작하는 vertax를 기준으로 거리가 적은 순서대로 돌아감.
    - visited 배열에 들어있는 vertax를 보면서 탐색을 이어가는 형태!

### 4. 트라이(Trie) 이론
- 검색 트리(Retrieval tree)
- 문자열을 저장하고 빠르게 탐색하기 위한 자료 구조
- 트라이를 구성하기 위한 별도의 메모리가 필요하나 매우 빠른 탐색이 가능
-> 단순 문자열 탐색: O(MN), 트라이에서 탐색: O(M)(M:문자열 길이, N:문자열 개수)
- 자료의 입력
    - 각 노드는 문자열의 각 문자를 의미
    - 루트 노드에서 시작해서, 문자열의 문자를 순서대로 자식 노드로 생성
    - 기존 같은 문자를 가진 자식 노드가 있으면, 새 노드를 생성하지 않고 해당 노드 사용
    - 모든 문자열의 입력이 끝나면, 마지막에 *(END) 입력
- 자료의 탐색
    - 루트 노드에서 시작해, 각 문자를 하나씩 자식 노드에서 찾아감.
    - 자식 노드 중에 문자가 없으면 해당 문자열은 트라이에 존재하지 않음.
    - 모든 문자를 탐색한 후, END 문자(*) 를 찾으면 해당 문자열은 트라이에 존재한다고 할 수 있음.