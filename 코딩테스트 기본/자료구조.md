# 자료구조

## 선형 자료구조
### 0. 기본

#### 배열
- 많은 수의 데이터를 다룰 때 사용하는 자료구조
- 각 데이터를 인덱스와 1:1 대응하도록 구성
- 데이터가 메모리 상에 연속적으로 저장됨.

- 특징
    - 크기(element) 의 개수가 정해져 있음.
    - 자료구조에 기능(메소드)이 포함되어있지 않음.
    - 자료가 메모리상에 빈틈 없이 연속적으로 위치해 있음.
    - 인덱스를 활용하여 자료에 빠르게 접근할 수 있음.
- 단점
    - 배열의 길이는 생성 시 정해져, 변경할 수 없음.
    - element 를 제거 시, 배열에 빈틈이 생김(빈틈 유지, 즉 실제 element 의 삭제 불가)

#### 리스트
- 순서가 있는 자료를 다루는 추상 자료형
- 추상 자료형이기 떄문에, 구현 방법이 명시되어 있지 않음.
- 대표적인 리스트를 구현한 자료 구조 - 배열 리스트, 연결 리스트
- 리스트 연산자
    - 비어있는 리스트 생성 연산자 : __init__()
    - 비어있는지 확인 : is_empty()
    - 앞에 개체 삽입 : pretend()
    - 뒤에 개체 삽입 : append()
    - 첫 머리를(head) 를 결정하는 연산자: set_head() (python slice)
    - 주어진 인덱스의 접근 : access(), get()
    - 주어진 인덱스에 삽입 : insert()
    - 주어진 인덱스 요소 제거 : remove()

---

### 1. 배열 리스트
- 내부적으로 배열을 이용하여 구현하는 리스트
- 리스트 추상자료형에서 요구하는 연산자를 배열을 활용하여 구현
- 배열의 장점인 임의접근이 핵심

### 2. 연결 리스트
- 리스트를 구현한 자료구조, 자료를 연결하여 관리하는 자료구조
- 자료의 순서는  정해져 있으나 메모리에서의 연속성은 보장하지 않음.
- 장점
    - 차지할 메모리를 미리 할당할 필요가 없음.
    -  자료의 추가/제거가 용이함.
- 단점
    - 자료간의 연결을 위한 추가 메모리가 필요함
    - 원하는 인덱스의 자료를 찾는 접근 속도가 느림, 임의 접근 불가
    - 배열 리스트에 비해 구현이 상대적으로 복잡함.
- 구조
    - 단반향 연결 리스트 : 자료의 값과 연결 정보를 가진 노드(node)로 구성
    - 양방향 연결 리스트 : 양방향으로 노드를 연결하는 이중 연결 구조
- 연결 리스트 연산자
    - 비어있는 리스트 생성 연산자 : __init__()
    - 비어있는지 확인 : is_empty()
    - 앞에 개체 삽입 : pretend()
    - 뒤에 개체 삽입 : append()
    - 첫 머리를(head) 를 결정하는 연산자: set_head() (python slice)
    - 주어진 인덱스의 접근 : access(), get()
    - 주어진 인덱스에 삽입 : insert()
    - 주어진 인덱스 요소 제거 : remove()

### 3. 스택
- 리스트와 달리 기능을 제한하는 추상자료형(ADT)
- 후입 선출의 특성
- 자료가 입력된 역순으로 처리되어야 할 떄 사용
- 스택의 연산자
    - push() : 자료를 top 위에 삽입하는 연산자
    - pop() : 자료를 top 에서 꺼내는 연산자
    - peek() : top에 있는 자료를 반환하지만, 삭제하지는 않는 연산자
    - is_empty() : 스택이 비어있는지 확인하는 연산자
- 스택의 구현
    - 배열을 사용하므로, 크기가 정해져 있음.
    - 메모리상 자료가 연속적이기 때문에 동작 속도가 빠름.
- 오버플로우와 언더플로우
    - 스택은 고속 동작을 위해 보통 배열로 구현
    - 오버플로우 : 스택이 가득 차있을때 push 시(메모리 공간 부족)
    - 언더플로우 : 스택이 비어있을 때 pop 시 (프로그램 버그)

### 4. 큐(Queue)
- 스택과 유사하게 기능을 제한하는 추상자료형(ADT)
- 선입선출의 특성
- 자료가 입력된 순서대로 처리되어야 할 떄 사용.
- 큐의 연산자
    - 큐는 자료를 넣는 곳, 빼는 곳이 따로 정해져 있음.(앞 : rear / 뒤 : front)
    - put(), enqueue() : 자료를 rear 로 삽입하는 연산자
    - get(), dequeue() : 자료를 front 에서 꺼내는 연산자
    - peek() : front 에 있는 자료를 반환하지만, 삭제하지는 않는 연산자
- 큐의 구현
    - 선형 큐
        - 배열을 이용하여 구현하는 가장 기본적인 큐
        - 문제점 : 한번 사용한 메모리 공간이 버려짐 + 반드시 오버플로우가 발생하는 구조적 문제
    - 환형 큐
        - 선형 큐의 시작과 끝을 연결해서 메모리를 재활용함.
        - 배열을 가득 채우기 전까지 오버플로우가 발생하지 않음.
        - 자료를 빼는 속도보다 넣는 속도가 빠른 경우는 오버플로우가 발생됨.
    - 연결 리스트 큐(실제 사용하는 큐의 형태)
        - 연결 리스트를 이용해 큐 구현
        - 구조적으로 메모리의 제약이 없음.

### 5. 해싱(Hashing)
- 해싱
    - 넓은 범위의 값을 더 좁은 범위의 값으로 변환하는 기법
    - 동일한 입력에 대해서 항상 동일한 출력을 보장
- 해시 함수(Hash function)
    - 해싱에 사용되는 함수로, 자주 사용되므로 빠른 동작이 요구됨.
    - 해시 충돌(Hash collision) : 다른 입력이 동일한 출력을 가질 수 있음.
    - python 에서 hash() 라는 내장 함수가 있음.

- 해시 셋(Hash set)
    - 해싱 기법을 이용하는 대표적인 자료구조
    - 한정된 크기를 가지는 버킷(bucket -> 배열) 을 이용해 자료를 저장
    - 자료를 저장하는 인덱스는 해시값(해시 함수의 출력)을 버킷의 크기로 나눈 나머지로 한다 (index = hash_value % bucket_size)
    - 특징
        - 파이썬에는 set 자료형으로 해시 셋 구성
        - 자료의 중복 허용하지 않음. + 자료를 빠르게 탐색 가능
        - 버킷이 가득 차면 버킷의 크기를 증가 + 재배치

- 해시 테이블(Hash table)
    - 해시 셋과 유사하나, 해시를 계산하는 key와 짝을 이루는 valu를 함께 버킷에 저장하는 자료 구조
    - 파이썬에서는 dict 의 형식으로 구현
    - key는 중복이 허용되지 않고, value는 중복이 허용됨.
    - 공간 복잡도를 희생하여 시간 복잡도를 낮추는 대표적인 자료구조(메모리를 많이 써서 빠른 가져오기가 가능)

- 해시 충돌(Hash collision)
    - 해시 함수가 서로 다른 입력에 대해 동일한 출력을 내는 경우
    - 해시 충돌이 100% 발생할 경우, 탐색 성능은 O(1) 에서 O(N)으로 감소
    - 해결 방법
        - 개방 주소법(Open addressing, closed hashing)
            - 버킷의 다른 index를 선택하여 자료를 저장하는 기법
            - 더 이상 해시 충돌이 발생하지 않을 때까지 반복
            - 종류
                - 선형 탐사(Linear probing) : index 를 1씩 이동
                - 이차 탐사(Quadratic probing) : index 를 1², 2² ~ 씩 이동
                - 이중 해싱(Double hashing) : 별도의 해시 함수로 이동 간격을 계산(가장 성능이 좋음)
        - 체이닝(Chaining)
            - 해시 충돌이 발생할 경우 버킷에 자료를 연결 리스트로 추가해 나가는 기법