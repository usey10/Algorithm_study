# 자료구조 및 알고리즘

## 1. 자료구조와 알고리즘 개요

### 자료구조 (Data Structure)
- 자료 값의 모임, 자료 간의 관계, 그리고 자료에 적용할 수 있는 **함수나 명령**을 포함한 개념
- **만능인 자료구조는 없으며**, 상황에 맞는 자료구조를 사용해야 한다.
- **자료(Data)** : 현실 세계로부터 수집한 사실이나 개념의 값 또는 이들의 집합
- (참고) 정보(Information) : 데이터를 특정 용도로 사용하기 위해 처리/가공한 것
  *(데이터 - 프로세스 → 정보)*


### 추상 자료형 (ADT, Abstract Data Type)
- 자료구조와 유사하지만, **구체적인 구현 방법은 정의되지 않은** 개념적 자료구조
- 추상 자료형(ADT) + 구현 → **자료구조**
- 예시:
  - **리스트(ADT) + 배열 → 배열 리스트 (Array List)**
  - **리스트(ADT) + 연결리스트 → 연결 리스트 (Linked List)**
- 객체지향 프로그래밍(OOP) 관점에서 보면, **추상 클래스(Abstract Class)** 역할을 한다.
- **Python의 list**는 ADT지만, 내부 구현이 정의되어 있기 때문에 사용법만 알면 된다.

---

## 2. 자료구조의 분류

### 2.1 선형 자료구조 (Linear Data Structure)
- **배열 (Array)** : 동일한 자료형을 가진 요소들이 연속된 메모리에 저장되는 구조
- **리스트 (List)** : 순서가 있는 데이터 구조
- **스택 (Stack)** : **후입선출 (LIFO, Last In First Out)**
- **큐 (Queue)** : **선입선출 (FIFO, First In First Out)**
- **해시 셋 (Hash Set)** : 중복 없는 집합 자료 구조
- **해시 테이블 (Hash Table)** : **(Key, Value)** 쌍을 저장하는 구조 (Python의 `dict`)

### 2.2 비선형 자료구조 (Nonlinear Data Structure)
- **트리 (Tree)** : 계층적인 자료구조
- **그래프 (Graph)** : 노드(Node)와 간선(Edge)으로 이루어진 자료구조
- **힙 (Heap, Priority Queue)** : 우선순위를 기준으로 요소를 정렬하는 자료구조
- **트라이 (Trie; Retrieval Tree)** : 문자열 검색을 최적화한 자료구조

---

## 3. 자료구조의 필요성
- **빠르고 효율적인 데이터 접근**을 가능하게 한다.
- **저장 장치의 효율적 사용**을 돕는다.
- **적절한 알고리즘을 적용**할 수 있게 한다.
- **협업과 유지보수성을 높인다.**

---

## 4. 알고리즘 (Algorithm)

### 4.1 알고리즘이란?
> **특정 문제를 해결하기 위한 절차나 방법**

### 4.2 알고리즘의 조건
1. **입력 (Input)** : 하나 이상의 입력이 있어야 한다.
2. **출력 (Output)** : 서로 다른 입력에 대해 최소 2가지 이상의 출력이 존재해야 한다.
3. **명확성 (Definiteness)** : 알고리즘의 각 단계는 명확해야 한다.
4. **유한성 (Finiteness)** : 유한한 시간 내에 종료되어야 한다.
5. **효과성 (Effectiveness)** : 모든 연산이 실제로 수행 가능해야 한다.

### 4.3 알고리즘의 분류

#### 기초 알고리즘 (Basic Algorithms)
- **정렬 (Sorting)** : 데이터를 특정 순서로 정렬하는 방법 (예: 버블 정렬, 퀵 정렬, 병합 정렬)
- **이진 탐색 (Binary Search)** : 정렬된 배열에서 원하는 값을 빠르게 찾는 방법
- **투 포인터 (Two Pointers)** : 배열에서 두 개의 포인터를 이용해 문제를 해결하는 기법
- **탐욕법 (Greedy Algorithm)** : 현재 상태에서 최적의 선택을 하는 알고리즘

#### 고급 알고리즘 (Advanced Algorithms)
- **분할 정복 (Divide & Conquer)** : 문제를 작은 문제로 나누어 해결하는 기법 (예: 병합 정렬, 퀵 정렬)
- **동적 계획법 (Dynamic Programming, DP)** : 중복 계산을 줄이기 위해 부분 문제의 결과를 저장하는 기법 (예: 피보나치 수열)
- **백트래킹 (Backtracking)** : 가능한 모든 경우를 탐색하는 기법 (예: N-Queen 문제)
- **최단 경로 (Shortest Path)** : 그래프에서 최단 경로를 찾는 알고리즘 (예: 다익스트라 알고리즘)
- **최소 신장 트리 (Minimum Spanning Tree, MST)** : 그래프에서 최소 비용으로 모든 정점을 연결하는 알고리즘 (예: 크루스칼, 프림 알고리즘)

---
## 5. 알고리즘의 복잡도

### 5.1 복잡도 (Complexity)
- 알고리즘의 성능을 나타내는 척도
- 시간 복잡도 (Time complexity) : 알고리즘을 동작하는데에 필요한 연산의 횟수
- 공간 복잡도 (Space complexity) : 알고리즘의 동작에 필요한 메모리의 크기
- 일반적으로 시간 복잡도와 공간 복잡도는 Trade-off 관계가 있다.

### 5.2 시간 복잡도 (Time complexity)
- 연산이 수행되는 횟수를 분석  
- 시간 복잡도가 낮을 수록 알고리즘의 성능이 좋다고 함.(빨리 동작하는지의 여부)
- 주요 시간 복잡도:
  - **O(1)** : 상수 시간
  - **O(log n)** : 로그 시간 (예: 이진 탐색)
  - **O(n)** : 선형 시간
  - **O(n log n)** : 로그 선형 시간 (예: 퀵 정렬, 병합 정렬)
  - **O(n²)** : 이차 시간 (예: 버블 정렬)
  - **O(2^n)** : 지수 시간 (예: 재귀적 피보나치)
  - **O(n!)** : 팩토리얼 시간 (예: 백트래킹 기반 순열 생성)

### 5.3 공간 복잡도 (Space complexity)
- 알고리즘의 동작에 필요한 RAM 의 크기(메모리, Random Access Memory, 주기억장치)
- 일반적으로 알고리즘이 동작하기 위해 필요한 메모리의 최대치(Peak memory)

### 5.4 복잡도의 점진적 표기법
점진적 표기법 : 알고리즘을 간편하게 정량적으로 비교하는 대표적인 방법

#### 복잡도의 비교
- 알고리즘 복잡도 비교의 어려운 점
- 시간 복잡도와 공간 복잡도의 Trade-off
- 자료의 크기, 자료의 내용에 따른 복잡도 차이

#### 복잡도의 분류
- 알고리즘 동작 상황에 따라 구분
    - 최악의 경우, 최선의 경우, 평균적인 경우
- 일반적으로 최악의 경우에 대해 알고리즘 복잡도 정의

#### 점진적 표기법
- 알고리즘에 입력되는 자료의 개수가 충분히 많다고 가정
- 성능 평가에 공평한 비교를 하기 위해 사용

### 5.5 빅 오 표기법
- **가장 영향력 있는 항을 기준으로 표기**
  - 예: `4N^2 - 3NlogN + 5N` → **O(N²)**
- 참고 *O(1) ∋ O(log N)*

## 6. 파이썬 주요 문법 Review

### 6.1 반복문 (for)
- `range()` 활용 : 인덱스 값을 통한 반복
- 반복자 활용 : for 문 안에서 반복 되어 리스트 값 반환
- `enumerate()` 활용 : 인덱스, 반복자 를 함꼐 반환
- `zip()` 활용 : 여러 반복자를 동시에 가지고 옴.(ex. 두개의 리스트)

### 6.2 함수 구현
- def 함수명(argument)

### 6.3 지능형 리스트
- **for 문보다 빠르게 동작함**
```python
a = [x for x in range(10)]
```

### 6.4 지능형 리스트의 친구들
- Generator : 미리 값을 만들지 않으므로 메모리를 적게 쓴다.
    ` a = (x for x in range(100000)) `
    매번 하나씩 자료를 만들어서 줌.
- Dictionay comprehension : 딕셔너리도 지능형 리스트 처럼 활용할 수 있음.
    ` a = {key:key**2 for key in range(10)} `

### 6.5 람다 표현식 : 함수 프로그래밍을 하기 위한 핵심 문법
- 함수 프로그래밍을 하기 위한 핵심 문법
    `print((lambda x: x**2)(10))`

### 6.6 조건 표현식(Conditional expression) : if 문 사용을 줄이는 핵심 문법
    ```python
    b = 20
    a = 1 if b > 0 else -1 
    ```

### 6.7 많이 쓰이는 함수 프로그래밍
- map(function, iterator) : 모든 요소에 함수 적용 *맵이라는 객체로 나옴 -> list 로 한번 더 묶어야 함*
    ```python
    a = [x for x in range(10)]
    a = list(map(lambda x:x**10, a))
    ```
- filter (function, iterator) : 조건에 맞는 요소만 필터링
    ```python
    a = [x for x in range(10)]
    a = list(filter(lambda x: x%2, a))
    ```
- reduce(function, iterator, 초기값) : 누적 연산 수행
    ```python
    from functools import reduce
    a = [x for x in range(100)]
    a = reduce(lambda x,y: x+y, a, 0)
    ```

### 6.8 클래스 구현
    - def __init__() : 생성자, 객체가 가지게 되는 멤버 변수 정의
    - def method
        - 클래스로 정의된 인스턴스는 a.method() 형식으로 불러올 수 있음.
        - def method(self, y): 
            - self : init 에서 정의한 멤버 변수를 가지고 오기 위한 정의
            - y : init 에서 정의되지 않고 추가적으로 불러올 수 있는 값
    - classmethod 데코레이터 (@classmethod) : 클래스변수명.~~ 으로 사용. 인스턴스 변수에는 접근 불가
    - @staticmethod : 클래스 내부의 접근 권한이 없음.(클래스와 연관성이 높은 경우 활용)


    